<h1>pyEchoNext / устройство веб-фреймворков</h1>
<hr />
<p>Наиболее важными частями веб-фрейморков являются:</p>
<ul>
<li>Обработчики маршрутизации (routes):</li>
<li>Простые: <code>/index</code></li>
<li>Параметризованные: <code>/article/{article_id}</code></li>
<li>Обработчики запросов (views).</li>
<li>Middleware</li>
<li>Request/Response</li>
<li>i18n/l10n</li>
<li>Конфигурация</li>
</ul>
<p>Основное требование: веб-фреймворк должен поддерживаться быстрым, легким и эффективным сервером (например gunicorn). Для этого в Python есть руководство по WSGI - <a href="https://peps.python.org/pep-0333/#the-application-framework-side">PEP 333</a>.</p>
<h2>Устройство веб-сервера на Python</h2>
<p>```
            ЗАПРОС
CLIENT &lt;--------------&gt; [HTTP (80) или HTTPS (443)] Сервер
             ОТВЕТ</p>
<pre><code>    &gt; Приложение с логикой
    &gt; Преобразование данных для python-приложения  &lt;-- Зона интересов веб-фреймвока (обеспечение работы gunicorn с ним)
    &gt; Gunicorn
    &gt; Преобразованные данные
</code></pre>
<p>СЕРВЕР -&gt; NGINX
        &gt; Маршрутизация данных
```</p>
<p>При разработки web-приложения на python мы сталкиваемся со следующими проблемами:</p>
<ul>
<li>Многие фреймворки (ex. django) не умеют маршрутизировать ответные запросы.</li>
<li>Приложения являются небезопасными, и могут быть подвержены DDoS-атаке (Distributed Denial of Service, распределенный отказ в обслуживании).</li>
<li>Нет балансировки нагрузки между несколькими серверами.</li>
<li>Проблему балансировки нагрузки решает NGINX, но он не умеет запускать и общаться с Python-приложениями.</li>
</ul>
<p>Поэтому и возникает нужда в использовании WSGI-сервера (Web Server Gateway Interface) и прокси-сервера (такого как NGINX).</p>
<h2>WSGI</h2>
<p>В настоящее время Python может похвастаться широким спектром фреймворков веб-приложений, таких как Zope, Quixote, Webware, SkunkWeb, PSO и Twisted Web — вот лишь некоторые из них. Такое широкое разнообразие вариантов может стать проблемой для новых пользователей Python, поскольку, как правило, их выбор веб-фреймворка ограничит их выбор используемых веб-серверов, и наоборот.</p>
<p>Напротив, хотя Java имеет столько же доступных фреймворков веб-приложений, API «servlet» Java позволяет приложениям, написанным с помощью любого фреймворка веб-приложений Java, работать на любом веб-сервере, который поддерживает API сервлетов.</p>
<p>Доступность и широкое использование такого API в веб-серверах для Python — независимо от того, написаны ли эти серверы на Python (например, Medusa), встроен ли Python (например, mod_python) или вызывают Python через протокол шлюза (например, CGI, FastCGI и т. д.) — отделит выбор фреймворка от выбора веб-сервера, позволяя пользователям выбирать подходящую им пару, в то же время освобождая разработчиков фреймворка и сервера для сосредоточения на их предпочтительной области специализации.</p>
<p>Таким образом, этот PEP предлагает простой и универсальный интерфейс между веб-серверами и веб-приложениями или фреймворками: интерфейс шлюза веб-сервера Python (WSGI).</p>
<p>Но само существование спецификации WSGI ничего не делает для решения существующего состояния серверов и фреймворков для веб-приложений Python. Авторы и сопровождающие серверов и фреймворков должны фактически реализовать WSGI, чтобы это имело какой-либо эффект.</p>
<p>Однако, поскольку ни один из существующих серверов или фреймворков не поддерживает WSGI, автор, который реализует поддержку WSGI, не получит немедленного вознаграждения.Таким образом, WSGI должен быть прост в реализации, чтобы первоначальные инвестиции автора в интерфейс могли быть достаточно низкими.</p>
<p>Таким образом, простота реализации как на стороне сервера, так и на стороне фреймворка интерфейса абсолютно критична для полезности интерфейса WSGI и, следовательно, является основным критерием для любых проектных решений.</p>
<p>Однако следует отметить, что простота реализации для автора фреймворка — это не то же самое, что простота использования для автора веб-приложения. WSGI представляет абсолютно «без излишеств» интерфейс для автора фреймворка, потому что такие навороты, как объекты ответа и обработка файлов cookie, просто помешают существующим фреймворкам решать эти проблемы. Опять же, цель WSGI — облегчить простое взаимодействие существующих серверов и приложений или фреймворков, а не создать новый веб-фреймворк.</p>
<p>Также следует отметить, что эта цель не позволяет WSGI требовать ничего, что еще не доступно в развернутых версиях Python. Поэтому новые модули стандартной библиотеки не предлагаются и не требуются этой спецификацией, и ничто в WSGI не требует версии Python выше 2.2.2. (Однако было бы неплохо, чтобы будущие версии Python включали поддержку этого интерфейса в веб-серверах, предоставляемых стандартной библиотекой.)</p>
<p>Помимо простоты реализации для существующих и будущих фреймворков и серверов, также должно быть легко создавать препроцессоры запросов, постпроцессоры ответов и другие компоненты «промежуточного программного обеспечения» на основе WSGI, которые выглядят как приложение для своего содержащего сервера, при этом выступая в качестве сервера для своих содержащихся приложений.Если промежуточное ПО может быть одновременно простым и надежным, а WSGI широко доступен в серверах и фреймворках, это допускает возможность совершенно нового типа фреймворка веб-приложений Python: состоящего из слабосвязанных компонентов промежуточного ПО WSGI. Действительно, существующие авторы фреймворков могут даже выбрать рефакторинг существующих служб своих фреймворков, чтобы они предоставлялись таким образом, становясь больше похожими на библиотеки, используемые с WSGI, и меньше на монолитные фреймворки. Это тогда позволило бы разработчикам приложений выбирать «лучшие в своем классе» компоненты для определенной функциональности, вместо того, чтобы брать на себя все плюсы и минусы одного фреймворка.</p>
<p>Конечно, на момент написания этой статьи этот день, несомненно, довольно далек. В то же время, это является достаточной краткосрочной целью для WSGI, чтобы обеспечить использование любого фреймворка с любым сервером.</p>
<p>Наконец, следует упомянуть, что текущая версия WSGI не предписывает какой-либо конкретный механизм для «развертывания» приложения для использования с веб-сервером или серверным шлюзом. В настоящее время это обязательно определяется реализацией сервера или шлюза. После того, как достаточное количество серверов и фреймворков внедрит WSGI для обеспечения практического опыта с различными требованиями к развертыванию, может иметь смысл создать еще один PEP, описывающий</p>
<h2>Цели pyEchoNext</h2>
<p>pyEchoNext - универсальный инструмент с возможностью сделать монолитное веб-приложение, или наоборот, модульное веб-приложение. Django для нас был слишком большой и неповоротливый, flask или fastapi слишком маленький. Поэтому мы решили взять некоторые фичи из django и flask/fastapi, соединить их и сделать так чтобы все это было в симбиозе. Так, чтобы можно было и сделать большой монолитный проект, так и маленький сервис. И чтобы превратить маленький сервис в большое приложение или наоборот требовалось минимум усилий.</p>
<p>Также нашими целями было сделать все это максимально понятным, дружественным к разработчику и добавить возможности интеграции сторонних библиотек.</p>
<p>В итоге, основная характеристика проекта такая:</p>
<ol>
<li>Цель: Создать универсальный многогранный веб-фреймворк на python</li>
<li>Задачи:</li>
<li>Найти хорошие и плохие стороны Flask, FastAPI</li>
<li>Найти хорошие и плохие стороны Django</li>
<li>Сравнить возможности существующих фреймворков</li>
<li>Выбор лучших фич</li>
<li>Симбиоз фич в одно целое</li>
<li>Построить код проекта согласно SOLID и принципам ООП, легко расширяемым, масштабируемым и дополняемым.</li>
<li>Сделать код быстрым и производительным, дать свободу пользователю и разработчику</li>
<li>Проблема: на данный момент очень мало универсальных фреймворков, дающих создать как и большое монолитное приложение, так и быстрый маленький сервис.</li>
<li>Актуальность: веб-сфера в данное время очень сильно популярна, умение работать с веб-фреймворками, абстракциями, знать устройство сайтов поможет всем.</li>
</ol>
<hr />
<p><a href="/docs?path=pyechonext/index.html">Содержание</a></p>